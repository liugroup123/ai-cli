import { createToolsIntegration } from './dist/core/tools/ai-tools-integration.js';
import path from 'path';
import fs from 'fs';

async function demonstrateMCPUsage() {
  console.log('üéØ AI CLI MCP Tools Demonstration\n');
  console.log('This demo shows how AI can use tools to perform real tasks!\n');

  const toolsIntegration = createToolsIntegration(process.cwd(), true);
  
  try {
    await toolsIntegration.initialize();
    
    console.log('‚úÖ MCP Tools System Initialized!');
    console.log('\nüì¶ Available Tools:');
    const tools = toolsIntegration.getToolSchemas();
    tools.forEach((tool, index) => {
      console.log(`  ${index + 1}. ${tool.name}: ${tool.description}`);
    });

    console.log('\nüé¨ Demo Scenarios:\n');

    // Scenario 1: Create a project file
    console.log('üìù Scenario 1: AI creates a project README');
    console.log('   Simulating: "Create a README.md file for this AI CLI project"');
    
    const readmePath = path.resolve(process.cwd(), 'AI_CLI_README.md');
    const readmeContent = `# AI CLI with MCP Tools

## Overview
This is an advanced AI-powered command line interface with Gemini CLI-style tool integration.

## Features
- ü§ñ Multiple AI providers (OpenAI, Claude, Gemini, Qwen)
- üîß MCP (Model Context Protocol) tool integration
- üìÅ File operations with diff preview
- üñ•Ô∏è Safe shell command execution
- üé® Beautiful React + Ink TUI interface

## Tools Available
${tools.map(t => `- **${t.name}**: ${t.description}`).join('\n')}

## Usage
\`\`\`bash
# Start interactive chat with tools
ai-cli chat --tui

# Single prompt with tools
ai-cli chat -p "Create a new component file"
\`\`\`

## MCP Integration
This project demonstrates how to integrate MCP tools similar to Google Gemini CLI:
- File system operations
- Git repository management  
- Web search capabilities
- Custom tool development

Generated by AI CLI MCP Tools on ${new Date().toISOString()}
`;

    const createFileResult = await toolsIntegration.executeToolCalls([
      {
        name: 'write_file',
        id: 'create_readme',
        parameters: {
          file_path: readmePath,
          content: readmeContent,
          description: 'Create project README with MCP tools info',
          create_directories: true
        }
      }
    ]);

    console.log(`   ‚úÖ Result: ${createFileResult[0].success ? 'SUCCESS' : 'FAILED'}`);
    if (createFileResult[0].success) {
      console.log('   üìÑ Created: AI_CLI_README.md');
    }

    // Scenario 2: List project structure
    console.log('\nüìÇ Scenario 2: AI explores project structure');
    console.log('   Simulating: "Show me the project structure"');
    
    const listResult = await toolsIntegration.executeToolCalls([
      {
        name: 'run_shell_command',
        id: 'list_structure',
        parameters: {
          command: process.platform === 'win32' ? 'dir /b' : 'ls -la',
          description: 'List project files and directories'
        }
      }
    ]);

    console.log(`   ‚úÖ Result: ${listResult[0].success ? 'SUCCESS' : 'FAILED'}`);
    if (listResult[0].success) {
      console.log('   üìã Project structure:');
      console.log('   ' + listResult[0].result.returnDisplay.split('\n').join('\n   '));
    }

    // Scenario 3: MCP filesystem tool
    console.log('\nüîå Scenario 3: AI uses MCP filesystem tool');
    console.log('   Simulating: "Read the package.json file"');
    
    const mcpReadResult = await toolsIntegration.executeToolCalls([
      {
        name: 'filesystem_read_file',
        id: 'read_package',
        parameters: {
          path: path.resolve(process.cwd(), 'package.json')
        }
      }
    ]);

    console.log(`   ‚úÖ Result: ${mcpReadResult[0].success ? 'SUCCESS' : 'FAILED'}`);
    console.log('   üìñ MCP Response:', mcpReadResult[0].result.returnDisplay.substring(0, 100) + '...');

    // Scenario 4: Create a component file
    console.log('\n‚öõÔ∏è Scenario 4: AI creates a React component');
    console.log('   Simulating: "Create a new React component for displaying tool status"');
    
    const componentPath = path.resolve(process.cwd(), 'ToolStatus.tsx');
    const componentContent = `import React from 'react';

interface ToolStatusProps {
  totalTools: number;
  connectedServers: number;
  lastUpdate: Date;
}

export const ToolStatus: React.FC<ToolStatusProps> = ({ 
  totalTools, 
  connectedServers, 
  lastUpdate 
}) => {
  return (
    <div className="tool-status">
      <h3>üîß MCP Tools Status</h3>
      <div className="stats">
        <div className="stat">
          <span className="label">Total Tools:</span>
          <span className="value">{totalTools}</span>
        </div>
        <div className="stat">
          <span className="label">Connected Servers:</span>
          <span className="value">{connectedServers}</span>
        </div>
        <div className="stat">
          <span className="label">Last Update:</span>
          <span className="value">{lastUpdate.toLocaleTimeString()}</span>
        </div>
      </div>
      <div className="status-indicator">
        {connectedServers > 0 ? (
          <span className="online">üü¢ MCP Online</span>
        ) : (
          <span className="offline">üî¥ MCP Offline</span>
        )}
      </div>
    </div>
  );
};

export default ToolStatus;
`;

    const createComponentResult = await toolsIntegration.executeToolCalls([
      {
        name: 'write_file',
        id: 'create_component',
        parameters: {
          file_path: componentPath,
          content: componentContent,
          description: 'Create React component for tool status display',
          create_directories: true
        }
      }
    ]);

    console.log(`   ‚úÖ Result: ${createComponentResult[0].success ? 'SUCCESS' : 'FAILED'}`);
    if (createComponentResult[0].success) {
      console.log('   ‚öõÔ∏è Created: ToolStatus.tsx');
    }

    // Scenario 5: Tool suggestions
    console.log('\nüí° Scenario 5: AI gets tool suggestions');
    const testMessages = [
      'I want to create a new Python script and run it',
      'Help me check the git status and commit changes',
      'Search for information about MCP protocol online'
    ];

    testMessages.forEach((message, index) => {
      console.log(`   ${index + 1}. "${message}"`);
      const suggestions = toolsIntegration.suggestToolsForMessage(message);
      console.log(`      Suggested: ${suggestions.map(t => t.name).join(', ')}`);
    });

    // Summary
    console.log('\nüìä Demo Summary:');
    const status = toolsIntegration.getToolStatus();
    console.log(`   ‚Ä¢ Total tools available: ${status.totalTools}`);
    console.log(`   ‚Ä¢ Built-in tools: ${status.builtinTools}`);
    console.log(`   ‚Ä¢ MCP tools: ${status.mcpTools}`);
    console.log(`   ‚Ä¢ Connected MCP servers: ${status.mcpServers.filter(s => s.connected).length}`);

    console.log('\nüéâ MCP Demo Completed Successfully!');
    console.log('\nüöÄ What this demonstrates:');
    console.log('   ‚úÖ AI can create and modify files with diff preview');
    console.log('   ‚úÖ AI can execute shell commands safely');
    console.log('   ‚úÖ AI can use MCP tools for extended functionality');
    console.log('   ‚úÖ AI gets intelligent tool suggestions');
    console.log('   ‚úÖ All operations are logged and can be confirmed');

    console.log('\nüìñ Next Steps:');
    console.log('   1. Try: ai-cli chat -p "Create a new TypeScript file"');
    console.log('   2. Try: ai-cli chat --tui (for interactive mode)');
    console.log('   3. Watch AI automatically choose and use tools!');

    // Cleanup demo files
    console.log('\nüßπ Cleaning up demo files...');
    try {
      if (fs.existsSync(readmePath)) fs.unlinkSync(readmePath);
      if (fs.existsSync(componentPath)) fs.unlinkSync(componentPath);
      console.log('   ‚úÖ Demo files cleaned up');
    } catch (error) {
      console.log('   ‚ö†Ô∏è Some demo files may remain');
    }

  } catch (error) {
    console.error('‚ùå Demo failed:', error.message);
    console.error('Stack:', error.stack);
  } finally {
    await toolsIntegration.shutdown();
  }
}

demonstrateMCPUsage().catch(console.error);
